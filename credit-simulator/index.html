<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Credit Band Payment Simulator</title>
  <link rel="stylesheet" href="../styles.css">
</head>
<body>
  <div class="container">
    <a href="../" class="back-link">&larr; Back to Tools</a>

    <header class="mb-lg">
      <h1>Credit Band Payment Simulator</h1>
    </header>

    <div class="info-box mb-lg">
      <strong>Payment Policy:</strong>
      <code>payment = max(pct(balance) * balance, minPayment(balance))</code>, then capped so you never overpay.
    </div>

    <div class="grid grid--2">
      <div class="card card--muted">
        <h3 class="mb-md mt-0">Inputs</h3>

        <div class="input-row">
          <div class="input-group">
            <label for="startingBalance">Starting Balance ($)</label>
            <input id="startingBalance" type="number" step="0.01" value="5000">
          </div>
          <div class="input-group">
            <label for="apr">APR (e.g. 0.2499 = 24.99%)</label>
            <input id="apr" type="number" step="0.0001" value="0.24">
          </div>
        </div>

        <div class="input-row">
          <div class="input-group">
            <label for="months">Months to simulate</label>
            <input id="months" type="number" step="1" value="24">
          </div>
          <div class="input-group" id="simpleChargesContainer">
            <label for="monthlyCharges">Monthly Charges ($, optional)</label>
            <input id="monthlyCharges" type="number" step="0.01" value="0">
          </div>
        </div>

        <div class="toggle-container">
          <label class="toggle-switch">
            <input type="checkbox" id="advancedModeToggle">
            <span class="toggle-slider"></span>
          </label>
          <span class="toggle-label">LEGENDARY Mode: Specify charges per month</span>
        </div>

        <div id="monthlyChargesSection" class="section section--hidden">
          <div class="card mt-md">
            <div class="section-header">
              <h4>Monthly Charges Schedule</h4>
              <button id="fillAllChargesBtn" class="btn btn--secondary btn--sm">Fill All</button>
            </div>
            <p class="text-small text-muted mt-sm">Enter different charge amounts for each month</p>
            <div id="monthlyChargesGrid" class="scrollable-grid"></div>
          </div>
        </div>

        <div class="btn-group mt-lg">
          <button id="runBtn" class="btn">Run Simulation</button>
          <button id="addBandBtn" class="btn btn--secondary">+ Add Band</button>
          <button id="resetBtn" class="btn btn--danger">Reset Example</button>
          <button id="downloadCsvBtn" class="btn btn--secondary">Download CSV</button>
        </div>

        <div class="btn-group mt-md">
          <button id="exportConfigBtn" class="btn btn--secondary">Export Config</button>
          <button id="importConfigBtn" class="btn btn--secondary">Import Config</button>
          <input type="file" id="importFileInput" accept=".json" style="display: none;">
        </div>

        <div class="mt-md">
          <span id="status" class="status"></span>
        </div>

        <h3 class="mt-xl mb-sm">Payment Bands</h3>
        <p class="text-small text-muted mb-md">
          Rows are matched by "largest lower bound &le; current balance". Keep lower bounds ascending.
        </p>

        <div style="overflow-x: auto;">
          <table id="bandsTable">
            <thead>
              <tr>
                <th>Lower Bound ($)</th>
                <th>Pct of Balance</th>
                <th>Min Payment ($)</th>
                <th class="text-right">Remove</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>

      <div class="card card--muted">
        <h3 class="mb-md mt-0">Balance & Payment Over Time</h3>
        <canvas id="chart" height="260"></canvas>
        <p id="chartNote" class="chart-note"></p>
      </div>
    </div>

    <div class="grid grid--2 mt-lg">
      <div class="card card--muted">
        <h3 class="mb-md mt-0">Payment vs Balance</h3>
        <canvas id="paymentVsBalanceChart" height="260"></canvas>
        <p class="chart-note">Shows how payment amount changes relative to current balance (scatter plot)</p>
      </div>
      <div class="card card--muted">
        <h3 class="mb-md mt-0">Payment Band Schedule</h3>
        <canvas id="bandChart" height="260"></canvas>
        <p class="chart-note">Theoretical payment amounts across balance ranges based on your bands</p>
      </div>
    </div>

    <div class="card mt-lg">
      <h3 class="mb-md mt-0">Monthly Results</h3>
      <div style="overflow-x: auto;">
        <table id="resultsTable">
          <thead>
            <tr>
              <th>Month</th>
              <th>Start Balance</th>
              <th>Interest</th>
              <th>Charges</th>
              <th>Payment</th>
              <th>End Balance</th>
              <th>Pct Used</th>
              <th>Min Payment</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Chart.js CDN -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <script>
    // ---------- helpers ----------
    const $ = (id) => document.getElementById(id);
    const round2 = (x) => Math.round((x + Number.EPSILON) * 100) / 100;
    const fmt = (x) => x.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });

    function setStatus(msg, type = "") {
      const el = $("status");
      el.textContent = msg || "";
      el.className = "status" + (type ? " status--" + type : "");
    }

    // ---------- advanced mode / monthly charges ----------
    let advancedMode = false;
    // Persistent storage for monthly charges - survives month count changes
    let monthlyChargesStorage = {};

    function toggleAdvancedMode() {
      advancedMode = $("advancedModeToggle").checked;
      $("monthlyChargesSection").classList.toggle("section--hidden", !advancedMode);
      $("simpleChargesContainer").style.display = advancedMode ? "none" : "block";
      if (advancedMode) {
        rebuildMonthlyChargesGrid();
      }
      run();
    }

    function rebuildMonthlyChargesGrid() {
      const months = parseInt($("months").value || "0", 10);
      const grid = $("monthlyChargesGrid");
      const defaultCharge = parseFloat($("monthlyCharges").value || "0");

      // Update persistent storage with current values from the grid
      grid.querySelectorAll("input").forEach(inp => {
        const m = parseInt(inp.dataset.month, 10);
        monthlyChargesStorage[m] = parseFloat(inp.value || "0");
      });

      grid.innerHTML = "";

      for (let m = 1; m <= months; m++) {
        const div = document.createElement("div");
        div.className = "scrollable-grid-item";

        // Use stored value if available, otherwise default
        const value = monthlyChargesStorage[m] !== undefined ? monthlyChargesStorage[m] : defaultCharge;

        div.innerHTML = `
          <label>Month ${m}</label>
          <input type="number" step="0.01" value="${value}" data-month="${m}">
        `;

        div.querySelector("input").addEventListener("input", run);
        grid.appendChild(div);
      }
    }

    function getMonthlyChargesArray() {
      const charges = [];
      $("monthlyChargesGrid").querySelectorAll("input").forEach(inp => {
        charges.push(parseFloat(inp.value || "0"));
      });
      return charges;
    }

    function fillAllCharges() {
      const value = prompt("Enter charge amount to fill all months:", "0");
      if (value === null) return;
      const num = parseFloat(value);
      if (isNaN(num)) return;

      $("monthlyChargesGrid").querySelectorAll("input").forEach(inp => {
        inp.value = num;
      });
      run();
    }

    // ---------- bands UI ----------
    function addBandRow(lower = 0, pct = 0.0, minPayment = 0) {
      const tr = document.createElement("tr");

      const tdLower = document.createElement("td");
      const tdPct = document.createElement("td");
      const tdMin = document.createElement("td");
      const tdRm = document.createElement("td");
      tdRm.className = "text-right";

      tdLower.innerHTML = `<input type="number" step="0.01" value="${lower}">`;
      tdPct.innerHTML   = `<input type="number" step="0.0001" value="${pct}">`;
      tdMin.innerHTML   = `<input type="number" step="0.01" value="${minPayment}">`;
      tdRm.innerHTML    = `<button class="btn-icon" title="Remove band">&times;</button>`;

      tdRm.querySelector("button").addEventListener("click", () => {
        tr.remove();
        run();
      });

      // auto-run on edits
      [tdLower, tdPct, tdMin].forEach(td => {
        td.querySelector("input").addEventListener("input", () => run());
      });

      tr.appendChild(tdLower);
      tr.appendChild(tdPct);
      tr.appendChild(tdMin);
      tr.appendChild(tdRm);

      $("bandsTable").querySelector("tbody").appendChild(tr);
    }

    function getBands() {
      const rows = [...$("bandsTable").querySelector("tbody").querySelectorAll("tr")];
      const bands = rows.map(tr => {
        const inputs = tr.querySelectorAll("input");
        return {
          lower: parseFloat(inputs[0].value || "0"),
          pct: parseFloat(inputs[1].value || "0"),
          minPayment: parseFloat(inputs[2].value || "0")
        };
      }).filter(b => !Number.isNaN(b.lower) && !Number.isNaN(b.pct) && !Number.isNaN(b.minPayment));

      bands.sort((a, b) => a.lower - b.lower);
      return bands;
    }

    function pickBand(bands, balance) {
      let chosen = bands[0];
      for (const b of bands) {
        if (balance >= b.lower) chosen = b;
        else break;
      }
      return chosen;
    }

    // ---------- simulation ----------
    function simulate({ startingBalance, apr, months, monthlyCharges, monthlyChargesArray, bands }) {
      const r = apr / 12.0;
      let balance = startingBalance;
      const out = [];

      for (let m = 1; m <= months; m++) {
        const interest = balance * r;
        // Use per-month charges if available, otherwise use flat monthly charge
        const charges = monthlyChargesArray && monthlyChargesArray[m - 1] !== undefined
          ? monthlyChargesArray[m - 1]
          : monthlyCharges;

        // Calculate outstanding balance (before payment) for minimum payment calculation
        const outstanding = balance + interest + charges;
        const band = pickBand(bands, outstanding);
        const rawPayment = band.pct * outstanding;
        let payment = Math.max(rawPayment, band.minPayment);

        // cap payment so we never go negative
        payment = Math.min(payment, outstanding);

        const endBalance = Math.max(0, outstanding - payment);

        out.push({
          month: m,
          startBalance: round2(balance),
          pct: band.pct,
          minPayment: band.minPayment,
          interest: round2(interest),
          charges: round2(charges),
          payment: round2(payment),
          endBalance: round2(endBalance)
        });

        balance = endBalance;
        // Don't break early - continue simulation even if balance hits 0
        // because future charges may bring the balance back up
      }
      return out;
    }

    // ---------- chart + table ----------
    let chart = null;
    let paymentVsBalanceChart = null;
    let bandChart = null;

    // Chart colors from design system
    const chartColors = {
      accent: '#38bdf8',
      accentGlow: 'rgba(56, 189, 248, 0.15)',
      success: '#22c55e',
      successGlow: 'rgba(34, 197, 94, 0.15)',
      purple: '#a78bfa',
      purpleGlow: 'rgba(167, 139, 250, 0.15)'
    };

    function renderChart(rows) {
      const ctx = $("chart").getContext("2d");
      const labels = rows.map(r => `M${r.month}`);
      const balance = rows.map(r => r.endBalance);
      const payment = rows.map(r => r.payment);

      if (chart) chart.destroy();
      if (!window.Chart) {
        $("chartNote").textContent = "Chart.js failed to load (CDN blocked?). You can still use the results table below.";
        return;
      }

      $("chartNote").textContent = "";

      chart = new Chart(ctx, {
        type: "line",
        data: {
          labels,
          datasets: [
            {
              label: "End Balance",
              data: balance,
              tension: 0.3,
              borderColor: chartColors.accent,
              backgroundColor: chartColors.accentGlow,
              fill: true
            },
            {
              label: "Payment",
              data: payment,
              tension: 0.3,
              borderColor: chartColors.success,
              backgroundColor: chartColors.successGlow,
              fill: true
            }
          ]
        },
        options: {
          responsive: true,
          interaction: { mode: "index", intersect: false },
          plugins: {
            legend: { position: "top" },
            tooltip: {
              callbacks: {
                label: function(context) {
                  return context.dataset.label + ": $" + fmt(context.parsed.y);
                }
              }
            }
          },
          scales: {
            y: {
              ticks: { callback: v => "$" + v.toLocaleString() },
              beginAtZero: true
            }
          }
        }
      });
    }

    function renderPaymentVsBalanceChart(rows) {
      const ctx = $("paymentVsBalanceChart").getContext("2d");

      if (paymentVsBalanceChart) paymentVsBalanceChart.destroy();
      if (!window.Chart) return;

      // Create scatter data: x = balance, y = payment
      const scatterData = rows.map(r => ({
        x: r.startBalance,
        y: r.payment
      }));

      paymentVsBalanceChart = new Chart(ctx, {
        type: "scatter",
        data: {
          datasets: [
            {
              label: "Payment vs Balance",
              data: scatterData,
              backgroundColor: chartColors.accent,
              borderColor: chartColors.accent,
              pointRadius: 6,
              pointHoverRadius: 8
            }
          ]
        },
        options: {
          responsive: true,
          plugins: {
            legend: { display: false },
            tooltip: {
              callbacks: {
                label: function(context) {
                  return `Balance: $${fmt(context.parsed.x)} → Payment: $${fmt(context.parsed.y)}`;
                }
              }
            }
          },
          scales: {
            x: {
              title: { display: true, text: "Current Balance ($)" },
              ticks: { callback: v => "$" + v.toLocaleString() }
            },
            y: {
              title: { display: true, text: "Payment ($)" },
              ticks: { callback: v => "$" + v.toLocaleString() },
              beginAtZero: true
            }
          }
        }
      });
    }

    function renderBandChart(bands, maxBalance) {
      const ctx = $("bandChart").getContext("2d");

      if (bandChart) bandChart.destroy();
      if (!window.Chart || !bands.length) return;

      // Generate points showing the payment schedule across balance ranges
      const points = [];
      const step = Math.max(10, maxBalance / 200);

      for (let bal = 0; bal <= maxBalance * 1.1; bal += step) {
        const band = pickBand(bands, bal);
        const payment = Math.max(band.pct * bal, band.minPayment);
        points.push({ x: bal, y: payment });
      }

      bandChart = new Chart(ctx, {
        type: "line",
        data: {
          datasets: [
            {
              label: "Calculated Payment",
              data: points,
              borderColor: chartColors.purple,
              backgroundColor: chartColors.purpleGlow,
              fill: true,
              tension: 0,
              pointRadius: 0
            }
          ]
        },
        options: {
          responsive: true,
          plugins: {
            legend: { display: false },
            tooltip: {
              callbacks: {
                label: function(context) {
                  return `At $${fmt(context.parsed.x)} balance → $${fmt(context.parsed.y)} payment`;
                }
              }
            }
          },
          scales: {
            x: {
              type: "linear",
              title: { display: true, text: "Balance ($)" },
              ticks: { callback: v => "$" + v.toLocaleString() }
            },
            y: {
              title: { display: true, text: "Payment ($)" },
              ticks: { callback: v => "$" + v.toLocaleString() },
              beginAtZero: true
            }
          }
        }
      });
    }

    function renderResults(rows) {
      const tbody = $("resultsTable").querySelector("tbody");
      tbody.innerHTML = "";

      for (const r of rows) {
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${r.month}</td>
          <td>$${fmt(r.startBalance)}</td>
          <td>$${fmt(r.interest)}</td>
          <td>$${fmt(r.charges)}</td>
          <td>$${fmt(r.payment)}</td>
          <td>$${fmt(r.endBalance)}</td>
          <td>${(r.pct * 100).toFixed(2)}%</td>
          <td>$${fmt(r.minPayment)}</td>
        `;
        tbody.appendChild(tr);
      }
    }

    function toCsv(rows) {
      const header = ["month", "start_balance", "interest", "charges", "payment", "end_balance", "pct", "min_payment"];
      const lines = [header.join(",")];
      for (const r of rows) {
        lines.push([
          r.month,
          r.startBalance,
          r.interest,
          r.charges,
          r.payment,
          r.endBalance,
          r.pct,
          r.minPayment
        ].join(","));
      }
      return lines.join("\n");
    }

    function download(filename, text) {
      const blob = new Blob([text], { type: "text/csv;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    // ---------- run ----------
    function run() {
      try {
        const startingBalance = parseFloat($("startingBalance").value || "0");
        const apr = parseFloat($("apr").value || "0");
        const months = parseInt($("months").value || "0", 10);
        const monthlyCharges = parseFloat($("monthlyCharges").value || "0");
        const bands = getBands();

        // Get per-month charges if in advanced mode
        let monthlyChargesArray = null;
        if (advancedMode) {
          monthlyChargesArray = getMonthlyChargesArray();
        }

        if (!bands.length) { setStatus("Add at least one band.", "error"); return; }
        if (!(months > 0)) { setStatus("Months must be > 0.", "error"); return; }
        if (!(startingBalance >= 0)) { setStatus("Starting balance must be >= 0.", "error"); return; }

        const rows = simulate({ startingBalance, apr, months, monthlyCharges, monthlyChargesArray, bands });
        renderChart(rows);
        renderPaymentVsBalanceChart(rows);
        // Use max balance from simulation (not just startingBalance) for band chart
        const maxBalanceInSim = Math.max(startingBalance, ...rows.map(r => r.startBalance), ...rows.map(r => r.endBalance));
        renderBandChart(bands, maxBalanceInSim);
        renderResults(rows);

        const finalBalance = rows[rows.length - 1]?.endBalance ?? 0;
        const totalPaid = rows.reduce((sum, r) => sum + r.payment, 0);
        const totalInterest = rows.reduce((sum, r) => sum + r.interest, 0);

        setStatus(
          `Simulated ${rows.length} month(s). Final balance: $${fmt(finalBalance)} | Total paid: $${fmt(totalPaid)} | Total interest: $${fmt(totalInterest)}`,
          "success"
        );
        window.__lastRows = rows;
      } catch (e) {
        console.error(e);
        setStatus("Error running simulation (check inputs).", "error");
      }
    }

    // ---------- import/export config ----------
    function exportConfig() {
      // Sync monthly charges storage with current grid values
      if (advancedMode) {
        $("monthlyChargesGrid").querySelectorAll("input").forEach(inp => {
          const m = parseInt(inp.dataset.month, 10);
          monthlyChargesStorage[m] = parseFloat(inp.value || "0");
        });
      }

      const config = {
        version: "1.0",
        startingBalance: parseFloat($("startingBalance").value || "0"),
        apr: parseFloat($("apr").value || "0"),
        months: parseInt($("months").value || "0", 10),
        monthlyCharges: parseFloat($("monthlyCharges").value || "0"),
        advancedMode: advancedMode,
        monthlyChargesStorage: advancedMode ? { ...monthlyChargesStorage } : {},
        bands: getBands()
      };

      const json = JSON.stringify(config, null, 2);
      const blob = new Blob([json], { type: "application/json;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "credit_config.json";
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);

      setStatus("Configuration exported successfully.", "success");
    }

    function importConfig(file) {
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const config = JSON.parse(e.target.result);

          // Validate required fields
          if (typeof config.startingBalance !== "number" ||
              typeof config.apr !== "number" ||
              typeof config.months !== "number" ||
              !Array.isArray(config.bands)) {
            throw new Error("Invalid config format");
          }

          // Apply basic inputs
          $("startingBalance").value = config.startingBalance;
          $("apr").value = config.apr;
          $("months").value = config.months;
          $("monthlyCharges").value = config.monthlyCharges || 0;

          // Clear existing bands
          const tbody = $("bandsTable").querySelector("tbody");
          tbody.innerHTML = "";

          // Add bands from config
          for (const band of config.bands) {
            addBandRow(band.lower || 0, band.pct || 0, band.minPayment || 0);
          }

          // Handle advanced mode
          if (config.advancedMode && config.monthlyChargesStorage) {
            monthlyChargesStorage = { ...config.monthlyChargesStorage };
            advancedMode = true;
            $("advancedModeToggle").checked = true;
            $("monthlyChargesSection").classList.remove("section--hidden");
            $("simpleChargesContainer").style.display = "none";
            rebuildMonthlyChargesGrid();
          } else {
            monthlyChargesStorage = {};
            advancedMode = false;
            $("advancedModeToggle").checked = false;
            $("monthlyChargesSection").classList.add("section--hidden");
            $("simpleChargesContainer").style.display = "block";
            $("monthlyChargesGrid").innerHTML = "";
          }

          run();
          setStatus("Configuration imported successfully.", "success");
        } catch (err) {
          console.error(err);
          setStatus("Failed to import configuration. Please check the file format.", "error");
        }
      };
      reader.onerror = function() {
        setStatus("Failed to read file.", "error");
      };
      reader.readAsText(file);
    }

    // ---------- init ----------
    function resetExample() {
      $("startingBalance").value = "5000";
      $("apr").value = "0.24";
      $("months").value = "24";
      $("monthlyCharges").value = "0";

      // Clear monthly charges storage and reset legendary mode
      monthlyChargesStorage = {};
      advancedMode = false;
      $("advancedModeToggle").checked = false;
      $("monthlyChargesSection").classList.add("section--hidden");
      $("simpleChargesContainer").style.display = "block";
      $("monthlyChargesGrid").innerHTML = "";

      const tbody = $("bandsTable").querySelector("tbody");
      tbody.innerHTML = "";

      // Example bands that demonstrate different payment strategies based on balance
      addBandRow(0, 0.00, 0);        // $0+: No payment (grace period for zero balance)
      addBandRow(100, 0.05, 25);     // $100+: 5% or $25 min
      addBandRow(500, 0.04, 35);     // $500+: 4% or $35 min
      addBandRow(1000, 0.03, 40);    // $1000+: 3% or $40 min
      addBandRow(3000, 0.025, 50);   // $3000+: 2.5% or $50 min

      run();
    }

    // Event listeners
    $("runBtn").addEventListener("click", run);
    $("addBandBtn").addEventListener("click", () => addBandRow(0, 0.03, 35));
    $("resetBtn").addEventListener("click", resetExample);
    $("downloadCsvBtn").addEventListener("click", () => {
      const rows = window.__lastRows || [];
      if (!rows.length) return setStatus("Run simulation first.", "error");
      download("credit_sim.csv", toCsv(rows));
    });

    // Advanced mode toggle
    $("advancedModeToggle").addEventListener("change", toggleAdvancedMode);
    $("fillAllChargesBtn").addEventListener("click", fillAllCharges);

    // Import/Export config
    $("exportConfigBtn").addEventListener("click", exportConfig);
    $("importConfigBtn").addEventListener("click", () => $("importFileInput").click());
    $("importFileInput").addEventListener("change", (e) => {
      if (e.target.files.length > 0) {
        importConfig(e.target.files[0]);
        e.target.value = ""; // Reset so same file can be imported again
      }
    });

    // Auto-run on input changes
    ["startingBalance", "apr", "monthlyCharges"].forEach(id => {
      $(id).addEventListener("input", run);
    });

    // Months input needs to rebuild the grid when in advanced mode
    $("months").addEventListener("input", () => {
      if (advancedMode) {
        rebuildMonthlyChargesGrid();
      }
      run();
    });

    // Initialize with example data
    resetExample();
  </script>
</body>
</html>
